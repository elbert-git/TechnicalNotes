<html>
  
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../../style.css">
    <base target="_parent">
  </head>
  
  <body class="ck-content">
     <h1>javascript</h1>

    
<h2><strong>-|- Advanced Javascript</strong></h2>

    <p>===================================================================</p>
    <p>This covers everything above the basic syntax, variables, loops. Will
      cover stuff like ES6, events and polymorphism/object-based-programming.</p>
    
<h2><strong>Objects</strong></h2>

    <p>===================================================================</p>
    <p>JSONs basically or a python dictionary</p>
    <p>basically an array but you can access by name on top of index</p>
<pre><code>let person = {name: "john", age:30};
</code></pre>

    <p>you can access data by dot notation or by square brackets</p>
<pre><code>console.log(person.name);
console.log(person['name']);
</code></pre>

    
<h4>adding new properties</h4>

<pre><code>obj.varName = value;
obj['varName'] = value;
</code></pre>

    
<h4>deleting properties</h4>

<pre><code>delete obj.varName;
</code></pre>

    
<h3>Ternary Operator</h3>

    <p>let val = (statement) ? (if true):(if false)</p>
<pre><code>let val = 2===2 ? "yes : "no";
console.log(val); // will return yes
</code></pre>

    
<h2><strong>ES6</strong></h2>

    <hr />
    
<h3>let var const variables</h3>

    <p>===================================================================</p>
    <ul>
      <li>ignore var</li>
      <li>just use let to declare variables</li>
      <li>const to declare constants (variables where the value won't change)</li>
    </ul>
<pre><code>//declare variables where the value can change
let a = 2;

// declare constant variables where value will not change. 
const pi = 22/7;
</code></pre>

    
<h3>Objects</h3>

    <p>============</p>
    
<h4>methods in objects</h4>

<pre><code>let obj = {
  name: "john",
  walk: function() {//walk},
  talk() {// talk}
}
</code></pre>

    
<h3>This</h3>

    <p>=======</p>
    <p>literally just a refernce to current object where this is called</p>
    <p>this is to be specific in scope when executing code</p>
<pre><code>let obj = {
  name: "john",
  getName() {return this.name}
} ;
</code></pre>

    
<h3>Binding "this"</h3>

<pre><code>const obj = {name: "jon", whatIsThis(){console.log this}};
let boundThis = obj.whatIsThis.bind(obj);

// now "this" will always be bound in to the object.
boundThis(); 
</code></pre>

    
<h3>Classes</h3>

    <p>============</p>
    <p>essentially object creators. they allow the code to create an object with
      specifications</p>
<pre><code>class person{
  constructor(name){
  this.name = name;
  }

  getName(){
   return name;
  }
}

const john = new person(john);
</code></pre>

    <p>you just class to define how an object is created.</p>
    <p>so that you don't have to define it by hand every time.</p>
    
<h4>The "super" keyword</h4>

    <p>it's essentially allowing you to call the parent class constructro to
      help construct a child class</p>
<pre><code>class person(){
  constructor(name, age){
    this.name = name;
    this.age = age;
  }
}

class teacher(){
  constructor(name, age, occupation){
    super(name, age)// so that you dont retype the constructor above
    this.occupation = age;
  }
}
</code></pre>

    
<h3>Arrow Function</h3>

    <p>============================</p>
    <p>just a tigher fucntion syntax for shorter code. easier to type and read.</p>
<pre><code>const square = function(num){return num*num};
const add = (a, b) =&gt; {return a+b};
const printTime = () =&gt; {console.log(time)};
</code></pre>

    
<h3>Modules</h3>

    <p>================</p>
    <p>import and exporting functionalities and data from other js files</p>
    <p>literally just making public functions or varibles</p>
    
<h4>Exporting</h4>

<pre><code>export const data = 01; 
export default function hello(){console.log("hello")}
export {data as dataVar};
export {data as dataVar, hello};
</code></pre>

    
<h4>Importing</h4>

<pre><code>import {data} from './..';
import hello from './..';
import {dataVar} from './..';
import {dataVar as dataFromFile, hello} from './..';
</code></pre>

    
<h4>basically</h4>

    <p>put export behind funcs/vars to make the importable to other files</p>
    <p>export default to mark the main export.</p>
    <p>if you do not use use export defautl. import with {object} from '../.';</p>
    <p>with export defautl you can omit the curly brackers.</p>
    
<h2><strong>ES 2016</strong></h2>

    <hr />
    
<h3>Callbacks</h3>

    <p>================</p>
    <p>essentially functions that are saved to be called in the future</p>
    <p>most common example is setTimeout()</p>
<pre><code>setTimeout(() =&gt; {//this fucntion is saved to be called later}, 1000);
</code></pre>

    
<h3>Promises</h3>

    <p>================</p>
    <p>essentially a slight evolution on callbacks</p>
    <p>it's a class that accepts 2 callbacks and a fucntion.</p>
    <p>1 callback for when the fucntion has an suceeds. another callback for
      when the fucntion fails.</p>
    <p>you decide what are the fail and success conditions</p>
<pre><code>const myPromise = new Promise(() =&gt; {
  const = Math.floor(Math.random() * 2);
  if(rand === 0){
     resolve(); // call the success path
  }
  else{
    reject(); // call the failure path
  }
});

myPromise().then{console.log("success")}.catch{console.log("failure};
// above will only succeed if number is zero.
</code></pre>

    
<h3>Asynchronous Functions</h3>

    <p>=========================================</p>
    <p>functions where you can wait for a slow operation to happen before moving
      onto the rest of code</p>
<pre><code>async function init(){
  download = await fetch('link'); // will wait
  await SlowFunction(); // will wai
  // rest of code runs after awaits
} 

fucntionHere(); // this will run first 
</code></pre>

    <ul>
      <li>this async function will pause but rest of the app rill run.</li>
    </ul>
    
<h4>They are also useful for timeouts</h4>

    <p>letting code wait before executing</p>
<pre><code>async function sleep() {
    // code here
    await timeout(3000);  // wait for 3s (3000ms)
    // more code here
}
</code></pre>

    
<h3>Events</h3>

    <p>===================================================================</p>
    <p><a href="https://www.youtube.com/watch?v=DzZXRvk3EGg">https://www.youtube.com/watch?v=DzZXRvk3EGg</a>
    </p>
    <ul>
      <li>it's like automatic function calls</li>
      <li>creating an event.</li>
      <li>Create event listener</li>
      <li>dispatch event.</li>
    </ul>
  </body>

</html>